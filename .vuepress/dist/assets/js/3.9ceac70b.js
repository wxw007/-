(window.webpackJsonp=window.webpackJsonp||[]).push([[3],{167:function(t,e,r){t.exports=r.p+"assets/img/1.4fd85c39.jpg"},171:function(t,e,r){"use strict";r.r(e);var s=[function(){var t=this.$createElement,e=this._self._c||t;return e("h1",{attrs:{id:"js基础"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#js基础","aria-hidden":"true"}},[this._v("#")]),this._v(" js基础")])},function(){var t=this.$createElement,e=this._self._c||t;return e("h2",{attrs:{id:"js数据数据类型"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#js数据数据类型","aria-hidden":"true"}},[this._v("#")]),this._v(" js数据数据类型")])},function(){var t=this.$createElement,e=this._self._c||t;return e("ol",[e("li",[this._v("原始类型 "),e("strong",[this._v("(6个)")])])])},function(){var t=this,e=t.$createElement,r=t._self._c||e;return r("ul",[r("li",[t._v("boolean")]),t._v(" "),r("li",[t._v("null")]),t._v(" "),r("li",[t._v("undefined")]),t._v(" "),r("li",[t._v("string")]),t._v(" "),r("li",[t._v("number")]),t._v(" "),r("li",[t._v("symbol")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("blockquote",[e("p",[this._v("原始类型都是按值传递")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("ol",{attrs:{start:"2"}},[e("li",[this._v("引用类型")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("ul",[e("li",[this._v("object")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("h2",{attrs:{id:"判断数据类型"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#判断数据类型","aria-hidden":"true"}},[this._v("#")]),this._v(" 判断数据类型")])},function(){var t=this,e=t.$createElement,r=t._self._c||e;return r("ul",[r("li",[r("code",[t._v("typeof")]),t._v(" 对于原始类型来说，除了 "),r("code",[t._v("null")]),t._v(" 都可以显示正确的类型")]),t._v(" "),r("li",[r("code",[t._v("typeof")]),t._v(" 对于对象来说，除了函数都会显示 "),r("code",[t._v("object")]),t._v("，所以说 "),r("code",[t._v("typeof")]),t._v(" 并不能准确判断变量到底是什么类型")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("blockquote",[e("p",[e("code",[this._v("typeof")]),this._v(" 只能判断原始类型")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("ul",[e("li",[e("code",[this._v("instanceof")]),this._v("用来判断A是否为B的实例，表达式为：A "),e("code",[this._v("instanceof")]),this._v(" B，如果A是B的实例，则返回true，否则返回false。"),e("code",[this._v("instanceof")]),this._v("检测的是原型，内部机制是通过判断对象的原型链中是否有类型的原型。")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("blockquote",[e("p",[e("code",[this._v("instanceof")]),this._v(" 只能用来判断两个对象是否属于实例关系， 而不能判断一个对象实例具体属于哪种类型。")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("ul",[e("li",[e("code",[this._v("constructor")]),this._v(": ' '.constructor === String")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("blockquote",[e("p",[this._v("null 和 undefined 无constructor，这种方法判断不了。 如果自定义对象，开发者重写prototype之后，原有的constructor会丢失。")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("ul",[e("li",[e("code",[this._v("Object.prototype.toString()")]),this._v("   toString()是Object的原型方法，调用该方法，默认返回当前对象的[[Class]]。这是一个内部属性，其格式为[object Xxx],其中Xxx就是对象的类型。对于"),e("code",[this._v("Object")]),this._v("对象，直接调用toString()就能返回[object Object],而对于其他对象，则需要通过call、apply来调用才能返回正确的类型信息。")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[this._v("Object.prototype.toString.call('') // [object String]\n")])])])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[e("code",[this._v("Object.prototype.toString()")]),this._v(" 是最推荐的")])},function(){var t=this.$createElement,e=this._self._c||t;return e("h2",{attrs:{id:"this"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#this","aria-hidden":"true"}},[this._v("#")]),this._v(" this")])},function(){var t=this.$createElement,e=this._self._c||t;return e("h3",{attrs:{id:"普通函数"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#普通函数","aria-hidden":"true"}},[this._v("#")]),this._v(" 普通函数")])},function(){var t=this.$createElement,e=this._self._c||t;return e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[this._v("function foo() {\n  console.log(this.a)\n}\nvar a = 1\nfoo()\n\nconst obj = {\n  a: 2,\n  foo: foo\n}\nobj.foo()\n\nconst c = new foo()\n")])])])},function(){var t=this.$createElement,e=this._self._c||t;return e("ul",[e("li",[this._v("对于直接调用 foo 来说，不管 foo 函数被放在了什么地方，this 一定是 window")]),this._v(" "),e("li",[this._v("对于 obj.foo() 来说，我们只需要记住，谁调用了函数，谁就是 this，所以在这个场景下 foo 函数中的 this 就是 obj 对象")]),this._v(" "),e("li",[this._v("对于 new 的方式来说，this 被永远绑定在了 c 上面，不会被任何方式改变 this")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("h3",{attrs:{id:"箭头函数"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#箭头函数","aria-hidden":"true"}},[this._v("#")]),this._v(" 箭头函数")])},function(){var t=this.$createElement,e=this._self._c||t;return e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[this._v("function a() {\n  return () => {\n    return () => {\n      console.log(this)\n    }\n  }\n}\nconsole.log(a()()())\n")])])])},function(){var t=this.$createElement,e=this._self._c||t;return e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[this._v("let a = {}\nlet fn = function () { console.log(this) }\nfn.bind().bind(a)() // => ?\n")])])])},function(){var t=this.$createElement,e=this._self._c||t;return e("h3",{attrs:{id:"this的优先级"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#this的优先级","aria-hidden":"true"}},[this._v("#")]),this._v(" this的优先级")])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[e("img",{attrs:{src:r(167),alt:"this流程图"}})])},function(){var t=this.$createElement,e=this._self._c||t;return e("h2",{attrs:{id:"闭包"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#闭包","aria-hidden":"true"}},[this._v("#")]),this._v(" 闭包")])},function(){var t=this.$createElement,e=this._self._c||t;return e("h3",{attrs:{id:"什么是闭包？"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#什么是闭包？","aria-hidden":"true"}},[this._v("#")]),this._v(" 什么是闭包？")])},function(){var t=this.$createElement,e=this._self._c||t;return e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[this._v("例子: 闭包实现一个函数，每次调用返回值加1\nfunction a(){\n    var n = 1;\n    return function(){\n       return n++\n    }\n}\nvar b = a()\n\nb() // 1\nb() // 2\nb() // 3\n")])])])},function(){var t=this.$createElement,e=this._self._c||t;return e("h3",{attrs:{id:"闭包的使用场景"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#闭包的使用场景","aria-hidden":"true"}},[this._v("#")]),this._v(" 闭包的使用场景")])},function(){var t=this.$createElement,e=this._self._c||t;return e("ol",[e("li",[this._v("实现私有成员。")]),this._v(" "),e("li",[this._v("保护命名空间，避免污染全局变量。")]),this._v(" "),e("li",[this._v("缓存变量。")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("blockquote",[e("p",[this._v("常见的用闭包解决循环打印数值一样的问题")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("h3",{attrs:{id:"使用闭包的注意事项"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#使用闭包的注意事项","aria-hidden":"true"}},[this._v("#")]),this._v(" 使用闭包的注意事项")])},function(){var t=this.$createElement,e=this._self._c||t;return e("ol",[e("li",[e("strong",[this._v("内存泄漏")]),this._v(" - 由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题")]),this._v(" "),e("li",[this._v("如果内部函数的变量和外部函数的变量名相同时，那么内部函数再也无法指向外部函数那个同名的变量")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("h2",{attrs:{id:"浅拷贝、深拷贝"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#浅拷贝、深拷贝","aria-hidden":"true"}},[this._v("#")]),this._v(" 浅拷贝、深拷贝")])},function(){var t=this.$createElement,e=this._self._c||t;return e("h3",{attrs:{id:"浅拷贝"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#浅拷贝","aria-hidden":"true"}},[this._v("#")]),this._v(" 浅拷贝")])},function(){var t=this.$createElement,e=this._self._c||t;return e("ol",[e("li",[e("code",[this._v("Object.assign")])]),this._v(" "),e("li",[this._v("扩展运算符 "),e("code",[this._v("...")])])])},function(){var t=this.$createElement,e=this._self._c||t;return e("h3",{attrs:{id:"深拷贝"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#深拷贝","aria-hidden":"true"}},[this._v("#")]),this._v(" 深拷贝")])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[this._v("通常用转字符串的方法进行深拷贝 "),e("code",[this._v("JSON.parse(JSON.stringify(object))")]),this._v("。\n但是此方法存在局限性")])},function(){var t=this,e=t.$createElement,r=t._self._c||e;return r("ul",[r("li",[t._v("会忽略 "),r("code",[t._v("undefined")])]),t._v(" "),r("li",[t._v("会忽略 "),r("code",[t._v("symbol")])]),t._v(" "),r("li",[t._v("不能序列化函数")]),t._v(" "),r("li",[t._v("不能解决循环引用的对象")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[this._v("let obj = {\n  a: 1,\n  b: {\n    c: 2,\n    d: 3,\n  },\n}\nobj.c = obj.b\nobj.e = obj.a\nobj.b.c = obj.c\nobj.b.d = obj.b\nobj.b.e = obj.b.c\nlet newObj = JSON.parse(JSON.stringify(obj))\nconsole.log(newObj)  //报错\n")])])])},function(){var t=this.$createElement,e=this._self._c||t;return e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[this._v("let a = {\n  age: undefined,\n  sex: Symbol('male'),\n  jobs: function() {},\n  name: 'yck'\n}\nlet b = JSON.parse(JSON.stringify(a))\nconsole.log(b) // {name: \"yck\"} 只剩下name\n")])])])},function(){var t=this.$createElement,e=this._self._c||t;return e("h2",{attrs:{id:"原型和原型链"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#原型和原型链","aria-hidden":"true"}},[this._v("#")]),this._v(" 原型和原型链")])},function(){var t=this.$createElement,e=this._self._c||t;return e("h3",{attrs:{id:"原型"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#原型","aria-hidden":"true"}},[this._v("#")]),this._v(" 原型")])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[this._v("每个 JS 对象都有 "),e("code",[this._v("__proto__")]),this._v(" 属性，这个属性指向了原型，实例的 "),e("code",[this._v("__proto__")]),this._v(" 属性(原型) 等于其构造函数的"),e("code",[this._v("prototype")]),this._v("。")])},function(){var t=this.$createElement,e=this._self._c||t;return e("h3",{attrs:{id:"原型链"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#原型链","aria-hidden":"true"}},[this._v("#")]),this._v(" 原型链")])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[this._v("对象的"),e("code",[this._v("__proto__")]),this._v(" 属性指向原型，"),e("code",[this._v("__proto__")]),this._v(" 将对象和原型连接起来组成了原型链。")])},function(){var t=this,e=t.$createElement,r=t._self._c||e;return r("p",[t._v("当在一个对象 obj 上访问某个属性时，如果不存在于 obj，那么便会去对象的原型也就是 "),r("code",[t._v("obj.__proto__")]),t._v("上去找这个属性。如果有则返回这个属性，没有则去对象 obj 的原型的原型也就是 "),r("code",[t._v("obj.__proto__.__proto__")]),t._v("去找，重复以上步骤。一直到访问纯对象的原型的原型"),r("code",[t._v("{}.__proto.__proto__")]),t._v("，也就是 "),r("code",[t._v("null")]),t._v("，直接返回 "),r("code",[t._v("undefined")]),t._v("。")])},function(){var t=this.$createElement,e=this._self._c||t;return e("h3",{attrs:{id:"new-运算符做了什么"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#new-运算符做了什么","aria-hidden":"true"}},[this._v("#")]),this._v(" new 运算符做了什么")])},function(){var t=this.$createElement,e=this._self._c||t;return e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[this._v("function F(){\n  console.log('这是构造函数')\n}\n\n// new 做了以下四步\nvar obj = {}; // 1. 创建一个空对象 obj\nobj.__proto__ = F.prototype; // 2. 将空对象的 __proto__ 指向F函数对象的prototype对象\nF.call(obj); // 3. 将F函数的 this 指向 obj, 并执行 F\nreturn obj; // 返回 obj\n\n// 自己实现一个 new 方法 \nfunction myNew(){\n  var obj = {}; // 1. 创建一个空对象 obj\n  var Constructor = [].shift.call(arguments) //2. 获取构造函数\n  obj.__proto__ = Constructor.prototype; //3. 将空对象的 __proto__ 指向构造函数的prototype对象\n  var result = Constructor.apply(obj, arguments); //4. 将 this 指向 obj, 并执行Constructor函数\n  return typeof result === \"object\" ? result : obj;//5. 如果返回值是一个对象就返回该对象，否则返回构造函数的一个实例对象\n}\n")])])])},function(){var t=this.$createElement,e=this._self._c||t;return e("h2",{attrs:{id:"var、let、const-区别"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#var、let、const-区别","aria-hidden":"true"}},[this._v("#")]),this._v(" var、let、const 区别")])},function(){var t=this.$createElement,e=this._self._c||t;return e("ul",[e("li",[this._v("函数提升优先于变量提升，函数提升会把整个函数挪到作用域顶部，变量提升只会把声明挪到作用域顶部。")]),this._v(" "),e("li",[this._v("var 存在提升，我们能在声明之前使用。let、const 因为暂时性死区的原因，不能在声明前使用。")]),this._v(" "),e("li",[this._v("var 在全局作用域下声明变量会导致变量挂载在 window 上，其他两者不会。")]),this._v(" "),e("li",[this._v("let 和 const 作用基本一致，但是后者声明的变量不能再次赋值。")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("h2",{attrs:{id:"模块化"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#模块化","aria-hidden":"true"}},[this._v("#")]),this._v(" 模块化")])},function(){var t=this.$createElement,e=this._self._c||t;return e("h3",{attrs:{id:"模块化的好处"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#模块化的好处","aria-hidden":"true"}},[this._v("#")]),this._v(" 模块化的好处")])},function(){var t=this.$createElement,e=this._self._c||t;return e("ul",[e("li",[this._v("解决命名冲突")]),this._v(" "),e("li",[this._v("提供复用性")]),this._v(" "),e("li",[this._v("提高代码可维护性")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("h3",{attrs:{id:"模块化的方式"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#模块化的方式","aria-hidden":"true"}},[this._v("#")]),this._v(" 模块化的方式")])},function(){var t=this.$createElement,e=this._self._c||t;return e("ol",[e("li",[this._v("立即执行函数")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[this._v("(function(globalVariable){\n   globalVariable.test = function() {}\n   // ... 声明各种变量、函数都不会污染全局作用域\n})(globalVariable)\n")])])])},function(){var t=this.$createElement,e=this._self._c||t;return e("ol",{attrs:{start:"2"}},[e("li",[this._v("AMD和CMD (现已比较少使用)")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[this._v("// AMD\ndefine(['./a', './b'], function(a, b) {\n  // 加载模块完毕可以使用\n  a.do()\n  b.do()\n})\n// CMD\ndefine(function(require, exports, module) {\n  // 加载模块\n  // 可以把 require 写在函数体的任意地方实现延迟加载\n  var a = require('./a')\n  a.doSomething()\n})\n")])])])},function(){var t=this.$createElement,e=this._self._c||t;return e("ol",{attrs:{start:"3"}},[e("li",[this._v("CommonJS")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[this._v("// a.js\nmodule.exports = {\n    a: 1\n}\n// or \nexports.a = 1\n\n// b.js\nvar module = require('./a.js')\nmodule.a // -> log 1\n")])])])},function(){var t=this.$createElement,e=this._self._c||t;return e("ol",{attrs:{start:"4"}},[e("li",[this._v("ES Module")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[this._v("// 引入模块 API\nimport XXX from './a.js'\nimport { XXX } from './a.js'\n// 导出模块 API\nexport function a() {}\nexport default function() {}\n")])])])},function(){var t=this.$createElement,e=this._self._c||t;return e("h2",{attrs:{id:"proxy"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#proxy","aria-hidden":"true"}},[this._v("#")]),this._v(" Proxy")])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[this._v("Vue3.0 中将会通过 "),e("code",[this._v("Proxy")]),this._v(" 来替换原本的 "),e("code",[this._v("Object.defineProperty")]),this._v(" 来实现数据响应式。")])},function(){var t=this.$createElement,e=this._self._c||t;return e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[this._v("let p = new Proxy(target, handler)\n")])])])},function(){var t=this,e=t.$createElement,r=t._self._c||e;return r("p",[r("code",[t._v("target")]),t._v(" 代表需要添加代理的对象，"),r("code",[t._v("handler")]),t._v(" 用来自定义对象中的操作，比如可以用来自定义 "),r("code",[t._v("set")]),t._v(" 或者 "),r("code",[t._v("get")]),t._v(" 函数。")])},function(){var t=this.$createElement,e=this._self._c||t;return e("h2",{attrs:{id:"数组遍历方法"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#数组遍历方法","aria-hidden":"true"}},[this._v("#")]),this._v(" 数组遍历方法")])},function(){var t=this.$createElement,e=this._self._c||t;return e("ol",[e("li",[e("h3",{attrs:{id:"普通for循环"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#普通for循环","aria-hidden":"true"}},[this._v("#")]),this._v(" 普通for循环")])])])},function(){var t=this.$createElement,e=this._self._c||t;return e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[this._v("var arr = [1, 2, 3]\nfor(var i = 0; i < arr.length; i++) { // 这里的i是代表数组的下标\n    console.log(i); // 0, 1, 2\n};\n")])])])},function(){var t=this.$createElement,e=this._self._c||t;return e("ol",{attrs:{start:"2"}},[e("li",[e("h3",{attrs:{id:"优化的-for-循环"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#优化的-for-循环","aria-hidden":"true"}},[this._v("#")]),this._v(" 优化的 for 循环")])])])},function(){var t=this.$createElement,e=this._self._c||t;return e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[this._v("var arr = [1, 2, 3]\nfor(var i = 0, len = arr.length; i < len; i++) { // 这里的i是代表数组的下标\nconsole.log(i); // 0, 1, 2 };　\n")])])])},function(){var t=this.$createElement,e=this._self._c||t;return e("ol",{attrs:{start:"3"}},[e("li",[e("h3",{attrs:{id:"for-of-遍历-这种遍历支持es6"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#for-of-遍历-这种遍历支持es6","aria-hidden":"true"}},[this._v("#")]),this._v(" for...of...遍历(这种遍历支持ES6)")])])])},function(){var t=this.$createElement,e=this._self._c||t;return e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[this._v("var arr = [1, 2, 3]\nfor(var item of arr) { // item代表数组里面的元素\n    console.log(item); // 1, 2, 3\n};　\n")])])])},function(){var t=this.$createElement,e=this._self._c||t;return e("ul",[e("li",[e("p",[this._v("这是最简洁、最直接的遍历数组元素的语法")])]),this._v(" "),e("li",[e("p",[this._v("这个方法避开了for-in循环的所有缺陷")])]),this._v(" "),e("li",[e("p",[this._v("与forEach()不同的是，它可以正确响应break、continue和return语句")])]),this._v(" "),e("li",[e("p",[this._v("性能要好于forin，但仍然比不上普通for循环")])])])},function(){var t=this.$createElement,e=this._self._c||t;return e("ol",{attrs:{start:"4"}},[e("li",[e("h3",{attrs:{id:"foreach"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#foreach","aria-hidden":"true"}},[this._v("#")]),this._v(" forEach()")])])])},function(){var t=this.$createElement,e=this._self._c||t;return e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[this._v("var arr = [1, 2, 3];\narr.forEach((item, index, arr) => { // item为arr的元素，index为下标，arr原数组\n    console.log(item); // 1, 2, 3\n    console.log(index); // 0, 1, 2\n    console.log(arr); // [1, 2, 3]\n});\n")])])])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[this._v("这种遍历便捷还是挺便捷的，看起来优雅，对目标数组的操作很人性化，要元素给元素，要下标给下标，但是当某种情况你想"),e("strong",[this._v("中断遍历")]),this._v("的时候，你就会感觉它就像鸡肋，食之无味，弃之可惜。由于foreach是Array型自带的，对于一些非这种类型的，无法直接使用(如NodeList)，所以才有了这个变种，使用这个变种可以让类似的数组拥有foreach功能。而且forEach的性能也会比普通的for循环弱。又下面的例子我们可以看到，我们常用的return false是可以终止代码继续往下执行的，但是在forEach遍历中，"),e("strong",[this._v("并没有终止循环")]),this._v("，所以在用forEach的时候，要考虑使用场景了。")])},function(){var t=this.$createElement,e=this._self._c||t;return e("ol",{attrs:{start:"5"}},[e("li",[e("h3",{attrs:{id:"some"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#some","aria-hidden":"true"}},[this._v("#")]),this._v(" some()")])])])},function(){var t=this.$createElement,e=this._self._c||t;return e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[this._v("var arr = [1, 2, 3];\narr.some((item, index, arr) => { // item为数组中的元素，index为下标，arr为目标数组\n    console.log(item); // 1, 2, 3\n    console.log(index); // 0, 1, 2\n    console.log(arr); // [1, 2, 3]  \n})\n")])])])},function(){var t=this.$createElement,e=this._self._c||t;return e("ul",[e("li",[e("p",[this._v("some作为一个用来检测数组是否满足一些条件的函数存在，同样是可以用作遍历的函数签名同forEach，有区别的是当任一callback返回值匹配为true则会直接返回true，如果所有的callback匹配均为false，则返回false。")])]),this._v(" "),e("li",[e("p",[this._v("some() 方法会依次执行数组的每个元素：")])]),this._v(" "),e("li",[e("p",[this._v("如果有一个元素满足条件，则表达式返回true , 剩余的元素不会再执行检测。")])]),this._v(" "),e("li",[e("p",[this._v("如果没有满足条件的元素，则返回false。")])])])},function(){var t=this.$createElement,e=this._self._c||t;return e("ol",{attrs:{start:"6"}},[e("li",[e("h3",{attrs:{id:"every"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#every","aria-hidden":"true"}},[this._v("#")]),this._v(" every()")])])])},function(){var t=this.$createElement,e=this._self._c||t;return e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[this._v("var arr = [1, 2, 3];\narr.every((item, index, arr) => { // item为数组中的元素，index为下标，arr为目标数组\n    return item > 0; // true\n    return index == 0; // false\n})\n")])])])},function(){var t=this.$createElement,e=this._self._c||t;return e("ul",[e("li",[this._v("every() 方法用于检测数组所有元素是否都符合指定条件（通过函数提供）。")]),this._v(" "),e("li",[this._v("every() 方法使用指定函数检测数组中的所有元素：")]),this._v(" "),e("li",[this._v("如果数组中检测到有一个元素不满足，则整个表达式返回 false ，且剩余的元素不会再进行检测。")]),this._v(" "),e("li",[this._v("如果所有元素都满足条件，则返回 true。")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("ol",{attrs:{start:"7"}},[e("li",[e("h3",{attrs:{id:"filter"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#filter","aria-hidden":"true"}},[this._v("#")]),this._v(" filter()")])])])},function(){var t=this.$createElement,e=this._self._c||t;return e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[this._v("var arr = [1, 2, 3];\narr.filter(item => { // item为数组当前的元素\n    return item > 1; // [2, 3]\n})\n")])])])},function(){var t=this.$createElement,e=this._self._c||t;return e("ul",[e("li",[this._v("filter() 方法创建一个新的数组，新数组中的元素是通过检查指定数组中符合条件的所有元素。")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("ol",{attrs:{start:"8"}},[e("li",[e("h3",{attrs:{id:"map"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#map","aria-hidden":"true"}},[this._v("#")]),this._v(" map()")])])])},function(){var t=this.$createElement,e=this._self._c||t;return e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[this._v("var arr = [1, 2, 3];\narr.map(item => { // item为数组的元素\n    console.log(item); // 1, 2, 3\n    return item * 2; // 返回一个处理过的新数组[2, 4, 6]\n})\n")])])])},function(){var t=this.$createElement,e=this._self._c||t;return e("ul",[e("li",[this._v("map() 方法返回一个新数组，数组中的元素为原始数组元素调用函数处理后的值。")]),this._v(" "),e("li",[this._v("map() 方法按照原始数组元素顺序依次处理元素。")]),this._v(" "),e("li",[this._v("这种方式也是用的比较广泛的，虽然用起来比较优雅，但实际效率还比不上forEach")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("ol",{attrs:{start:"9"}},[e("li",[e("h3",{attrs:{id:"reduce"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#reduce","aria-hidden":"true"}},[this._v("#")]),this._v(" reduce()")])])])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[e("code",[this._v("reduce")]),this._v(" 可以将数组中的元素通过回调函数最终转换为一个值。")])},function(){var t=this.$createElement,e=this._self._c||t;return e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[this._v("const arr = [1, 2, 3]\nconst sum = arr.reduce((acc, current) => acc + current, 0)\nconsole.log(sum)\n")])])])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[this._v("对于 "),e("code",[this._v("reduce")]),this._v(" 来说，它接受两个参数，分别是回调函数和初始值。")])},function(){var t=this.$createElement,e=this._self._c||t;return e("ul",[e("li",[this._v("首先初始值为 0，该值会在执行第一次回调函数时作为第一个参数传入")]),this._v(" "),e("li",[this._v("回调函数接受四个参数，分别为累计值、当前元素、当前索引、原数组，后三者想必大家都可以明白作用，这里着重分析第一个参数")]),this._v(" "),e("li",[this._v("在一次执行回调函数时，当前值和初始值相加得出结果 1，该结果会在第二次执行回调函数时当做第一个参数传入")]),this._v(" "),e("li",[this._v("所以在第二次执行回调函数时，相加的值就分别是 1 和 2，以此类推，循环结束后得到结果 6")])])}],a=r(0),i=Object(a.a)({},function(){var t=this,e=t.$createElement,r=t._self._c||e;return r("div",{staticClass:"content"},[t._m(0),t._v(" "),t._m(1),t._v(" "),t._m(2),t._v(" "),t._m(3),t._v(" "),t._m(4),t._v(" "),t._m(5),t._v(" "),t._m(6),t._v(" "),t._m(7),t._v(" "),t._m(8),t._v(" "),t._m(9),t._v(" "),t._m(10),t._v(" "),t._m(11),t._v(" "),t._m(12),t._v(" "),t._m(13),t._v(" "),t._m(14),t._v(" "),t._m(15),t._m(16),t._v(" "),t._m(17),t._v(" "),t._m(18),t._v(" "),t._m(19),t._m(20),t._v(" "),t._m(21),t._v(" "),t._m(22),r("p",[t._v("首先箭头函数其实是没有 this 的，箭头函数中的 this 只取决包裹箭头函数的第一个普通函数的 this。在这个例子中，因为包裹箭头函数的第一个普通函数是 a，所以此时的 this 是 window。另外对箭头函数使用 bind 这类函数是无效的。\nå\n最后种情况也就是 bind 这些改变上下文的 API 了，对于这些函数来说，this 取决于第一个参数，如果第一个参数为空，那么就是 window。")]),t._v(" "),r("p",[t._v("如果对一个函数进行多次 bind，那么上下文会是什么呢？")]),t._v(" "),t._m(23),r("p",[t._v("不管我们给函数 bind 几次，fn 中的 this 永远由第一次 bind 决定")]),t._v(" "),t._m(24),t._v(" "),r("p",[t._v("首先，new 的方式优先级最高，接下来是 bind 这些函数，然后是 obj.foo() 这种调用方式，最后是 foo 这种调用方式，同时，箭头函数的 this 一旦被绑定，就不会再被任何方式所改变。")]),t._v(" "),t._m(25),t._v(" "),t._m(26),t._v(" "),t._m(27),t._v(" "),r("p",[t._v("闭包就是指有权访问另一个函数作用域中的变量的函数。外部函数调用之后其变量对象本应该被销毁，但闭包的存在使我们仍然可以访问外部函数的变量对象")]),t._v(" "),t._m(28),t._m(29),t._v(" "),t._m(30),t._v(" "),t._m(31),t._v(" "),t._m(32),t._v(" "),t._m(33),t._v(" "),t._m(34),t._v(" "),t._m(35),t._v(" "),t._m(36),t._v(" "),t._m(37),t._v(" "),t._m(38),t._v(" "),t._m(39),t._v(" "),t._m(40),t._m(41),r("p",[t._v("需要深拷贝推荐使用 "),r("a",{attrs:{href:"https://lodash.com/docs/4.17.15#cloneDeep",target:"_blank",rel:"noopener noreferrer"}},[t._v(" lodash 的深拷贝函数"),r("OutboundLink")],1)]),t._v(" "),t._m(42),t._v(" "),t._m(43),t._v(" "),t._m(44),t._v(" "),t._m(45),t._v(" "),t._m(46),t._v(" "),t._m(47),t._v(" "),t._m(48),t._v(" "),t._m(49),t._m(50),t._v(" "),t._m(51),t._v(" "),t._m(52),t._v(" "),t._m(53),t._v(" "),t._m(54),t._v(" "),t._m(55),t._v(" "),t._m(56),t._v(" "),r("p",[t._v("在早期，使用立即执行函数实现模块化是常见的手段，通过函数作用域解决了命名冲突、污染全局作用域的问题。")]),t._v(" "),t._m(57),t._m(58),t._v(" "),t._m(59),t._m(60),t._v(" "),t._m(61),t._m(62),t._v(" "),t._m(63),t._m(64),t._v(" "),t._m(65),t._v(" "),t._m(66),t._m(67),t._v(" "),r("p",[t._v("Vue 中的响应式，需要我们在 get 中收集依赖，在 set 派发更新，之所以 Vue3.0 要使用 Proxy 替换原本的 API 原因在于 Proxy 无需一层层递归为每个属性添加代理，一次即可完成以上操作，性能上更好，并且原本的实现有一些数据更新不能监听到，但是 Proxy 可以完美监听到任何方式的数据改变，唯一缺陷可能就是浏览器的兼容性不好了。")]),t._v(" "),t._m(68),t._v(" "),t._m(69),t._v(" "),t._m(70),t._m(71),t._v(" "),t._m(72),r("p",[t._v("使用临时变量，将长度缓存起来，避免重复获取数组长度，当数组较大时优化效果才会比较明显。这种方法基本上是所有循环遍历方法中性能最高的一种，并且这一类型的for循环可以通过用break来中断循环。")]),t._v(" "),t._m(73),t._v(" "),t._m(74),t._m(75),t._v(" "),t._m(76),t._v(" "),t._m(77),t._m(78),t._v(" "),t._m(79),t._v(" "),t._m(80),t._m(81),t._v(" "),t._m(82),t._v(" "),t._m(83),t._m(84),t._v(" "),t._m(85),t._v(" "),t._m(86),t._m(87),t._v(" "),t._m(88),t._v(" "),t._m(89),t._m(90),t._v(" "),t._m(91),t._v(" "),t._m(92),t._v(" "),t._m(93),t._m(94),t._v(" "),r("p",[t._v("reduce 过程")]),t._v(" "),t._m(95)])},s,!1,null,null,null);e.default=i.exports}}]);