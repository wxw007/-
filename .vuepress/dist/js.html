<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>js基础 | 虎皮猫的博客</title>
    <meta name="description" content="个人博客-wxw">
    
    
    <link rel="preload" href="/blog/assets/css/0.styles.583a6a78.css" as="style"><link rel="preload" href="/blog/assets/js/app.186be814.js" as="script"><link rel="preload" href="/blog/assets/js/3.9ceac70b.js" as="script"><link rel="prefetch" href="/blog/assets/js/10.fb3f107b.js"><link rel="prefetch" href="/blog/assets/js/11.2fb24d1c.js"><link rel="prefetch" href="/blog/assets/js/12.2f120377.js"><link rel="prefetch" href="/blog/assets/js/13.a777a12e.js"><link rel="prefetch" href="/blog/assets/js/14.7bcff963.js"><link rel="prefetch" href="/blog/assets/js/15.8de5b498.js"><link rel="prefetch" href="/blog/assets/js/2.a9f2a1df.js"><link rel="prefetch" href="/blog/assets/js/4.3d8207ce.js"><link rel="prefetch" href="/blog/assets/js/5.9c241dba.js"><link rel="prefetch" href="/blog/assets/js/6.9d5079a1.js"><link rel="prefetch" href="/blog/assets/js/7.bb3e09c7.js"><link rel="prefetch" href="/blog/assets/js/8.15834562.js"><link rel="prefetch" href="/blog/assets/js/9.23bf0e30.js">
    <link rel="stylesheet" href="/blog/assets/css/0.styles.583a6a78.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/blog/" class="home-link router-link-active"><!----> <span class="site-name">虎皮猫的博客</span></a> <div class="links" style="max-width:nullpx;"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="https://github.com/wxw007/learning-note" target="_blank" rel="noopener noreferrer" class="nav-link external">
  github
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <div class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="https://github.com/wxw007/learning-note" target="_blank" rel="noopener noreferrer" class="nav-link external">
  github
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav>  <ul class="sidebar-links"><li><a href="/blog/html.html" class="sidebar-link">HTML 基础</a></li><li><a href="/blog/css.html" class="sidebar-link">CSS 基础</a></li><li><a href="/blog/js.html" class="active sidebar-link">js基础</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/js.html#js数据数据类型" class="sidebar-link">js数据数据类型</a></li><li class="sidebar-sub-header"><a href="/blog/js.html#判断数据类型" class="sidebar-link">判断数据类型</a></li><li class="sidebar-sub-header"><a href="/blog/js.html#this" class="sidebar-link">this</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/js.html#普通函数" class="sidebar-link">普通函数</a></li><li class="sidebar-sub-header"><a href="/blog/js.html#箭头函数" class="sidebar-link">箭头函数</a></li><li class="sidebar-sub-header"><a href="/blog/js.html#this的优先级" class="sidebar-link">this的优先级</a></li></ul></li><li class="sidebar-sub-header"><a href="/blog/js.html#闭包" class="sidebar-link">闭包</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/js.html#什么是闭包？" class="sidebar-link">什么是闭包？</a></li><li class="sidebar-sub-header"><a href="/blog/js.html#闭包的使用场景" class="sidebar-link">闭包的使用场景</a></li><li class="sidebar-sub-header"><a href="/blog/js.html#使用闭包的注意事项" class="sidebar-link">使用闭包的注意事项</a></li></ul></li><li class="sidebar-sub-header"><a href="/blog/js.html#浅拷贝、深拷贝" class="sidebar-link">浅拷贝、深拷贝</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/js.html#浅拷贝" class="sidebar-link">浅拷贝</a></li><li class="sidebar-sub-header"><a href="/blog/js.html#深拷贝" class="sidebar-link">深拷贝</a></li></ul></li><li class="sidebar-sub-header"><a href="/blog/js.html#原型和原型链" class="sidebar-link">原型和原型链</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/js.html#原型" class="sidebar-link">原型</a></li><li class="sidebar-sub-header"><a href="/blog/js.html#原型链" class="sidebar-link">原型链</a></li><li class="sidebar-sub-header"><a href="/blog/js.html#new-运算符做了什么" class="sidebar-link">new 运算符做了什么</a></li></ul></li><li class="sidebar-sub-header"><a href="/blog/js.html#var、let、const-区别" class="sidebar-link">var、let、const 区别</a></li><li class="sidebar-sub-header"><a href="/blog/js.html#模块化" class="sidebar-link">模块化</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/js.html#模块化的好处" class="sidebar-link">模块化的好处</a></li><li class="sidebar-sub-header"><a href="/blog/js.html#模块化的方式" class="sidebar-link">模块化的方式</a></li></ul></li><li class="sidebar-sub-header"><a href="/blog/js.html#proxy" class="sidebar-link">Proxy</a></li><li class="sidebar-sub-header"><a href="/blog/js.html#数组遍历方法" class="sidebar-link">数组遍历方法</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/js.html#普通for循环" class="sidebar-link">普通for循环</a></li><li class="sidebar-sub-header"><a href="/blog/js.html#优化的-for-循环" class="sidebar-link">优化的 for 循环</a></li><li class="sidebar-sub-header"><a href="/blog/js.html#for-of-遍历-这种遍历支持es6" class="sidebar-link">for...of...遍历(这种遍历支持ES6)</a></li><li class="sidebar-sub-header"><a href="/blog/js.html#foreach" class="sidebar-link">forEach()</a></li><li class="sidebar-sub-header"><a href="/blog/js.html#some" class="sidebar-link">some()</a></li><li class="sidebar-sub-header"><a href="/blog/js.html#every" class="sidebar-link">every()</a></li><li class="sidebar-sub-header"><a href="/blog/js.html#filter" class="sidebar-link">filter()</a></li><li class="sidebar-sub-header"><a href="/blog/js.html#map" class="sidebar-link">map()</a></li><li class="sidebar-sub-header"><a href="/blog/js.html#reduce" class="sidebar-link">reduce()</a></li></ul></li></ul></li><li><a href="/blog/vue.html" class="sidebar-link">vue面试题</a></li><li><a href="/blog/git.html" class="sidebar-link">git 使用以及规范</a></li></ul> </div> <div class="page"> <div class="content"><h1 id="js基础"><a href="#js基础" aria-hidden="true" class="header-anchor">#</a> js基础</h1> <h2 id="js数据数据类型"><a href="#js数据数据类型" aria-hidden="true" class="header-anchor">#</a> js数据数据类型</h2> <ol><li>原始类型 <strong>(6个)</strong></li></ol> <ul><li>boolean</li> <li>null</li> <li>undefined</li> <li>string</li> <li>number</li> <li>symbol</li></ul> <blockquote><p>原始类型都是按值传递</p></blockquote> <ol start="2"><li>引用类型</li></ol> <ul><li>object</li></ul> <h2 id="判断数据类型"><a href="#判断数据类型" aria-hidden="true" class="header-anchor">#</a> 判断数据类型</h2> <ul><li><code>typeof</code> 对于原始类型来说，除了 <code>null</code> 都可以显示正确的类型</li> <li><code>typeof</code> 对于对象来说，除了函数都会显示 <code>object</code>，所以说 <code>typeof</code> 并不能准确判断变量到底是什么类型</li></ul> <blockquote><p><code>typeof</code> 只能判断原始类型</p></blockquote> <ul><li><code>instanceof</code>用来判断A是否为B的实例，表达式为：A <code>instanceof</code> B，如果A是B的实例，则返回true，否则返回false。<code>instanceof</code>检测的是原型，内部机制是通过判断对象的原型链中是否有类型的原型。</li></ul> <blockquote><p><code>instanceof</code> 只能用来判断两个对象是否属于实例关系， 而不能判断一个对象实例具体属于哪种类型。</p></blockquote> <ul><li><code>constructor</code>: ' '.constructor === String</li></ul> <blockquote><p>null 和 undefined 无constructor，这种方法判断不了。 如果自定义对象，开发者重写prototype之后，原有的constructor会丢失。</p></blockquote> <ul><li><code>Object.prototype.toString()</code>   toString()是Object的原型方法，调用该方法，默认返回当前对象的[[Class]]。这是一个内部属性，其格式为[object Xxx],其中Xxx就是对象的类型。对于<code>Object</code>对象，直接调用toString()就能返回[object Object],而对于其他对象，则需要通过call、apply来调用才能返回正确的类型信息。</li></ul> <div class="language- extra-class"><pre class="language-text"><code>Object.prototype.toString.call('') // [object String]
</code></pre></div><p><code>Object.prototype.toString()</code> 是最推荐的</p> <h2 id="this"><a href="#this" aria-hidden="true" class="header-anchor">#</a> this</h2> <h3 id="普通函数"><a href="#普通函数" aria-hidden="true" class="header-anchor">#</a> 普通函数</h3> <div class="language- extra-class"><pre class="language-text"><code>function foo() {
  console.log(this.a)
}
var a = 1
foo()

const obj = {
  a: 2,
  foo: foo
}
obj.foo()

const c = new foo()
</code></pre></div><ul><li>对于直接调用 foo 来说，不管 foo 函数被放在了什么地方，this 一定是 window</li> <li>对于 obj.foo() 来说，我们只需要记住，谁调用了函数，谁就是 this，所以在这个场景下 foo 函数中的 this 就是 obj 对象</li> <li>对于 new 的方式来说，this 被永远绑定在了 c 上面，不会被任何方式改变 this</li></ul> <h3 id="箭头函数"><a href="#箭头函数" aria-hidden="true" class="header-anchor">#</a> 箭头函数</h3> <div class="language- extra-class"><pre class="language-text"><code>function a() {
  return () =&gt; {
    return () =&gt; {
      console.log(this)
    }
  }
}
console.log(a()()())
</code></pre></div><p>首先箭头函数其实是没有 this 的，箭头函数中的 this 只取决包裹箭头函数的第一个普通函数的 this。在这个例子中，因为包裹箭头函数的第一个普通函数是 a，所以此时的 this 是 window。另外对箭头函数使用 bind 这类函数是无效的。
å
最后种情况也就是 bind 这些改变上下文的 API 了，对于这些函数来说，this 取决于第一个参数，如果第一个参数为空，那么就是 window。</p> <p>如果对一个函数进行多次 bind，那么上下文会是什么呢？</p> <div class="language- extra-class"><pre class="language-text"><code>let a = {}
let fn = function () { console.log(this) }
fn.bind().bind(a)() // =&gt; ?
</code></pre></div><p>不管我们给函数 bind 几次，fn 中的 this 永远由第一次 bind 决定</p> <h3 id="this的优先级"><a href="#this的优先级" aria-hidden="true" class="header-anchor">#</a> this的优先级</h3> <p>首先，new 的方式优先级最高，接下来是 bind 这些函数，然后是 obj.foo() 这种调用方式，最后是 foo 这种调用方式，同时，箭头函数的 this 一旦被绑定，就不会再被任何方式所改变。</p> <p><img src="/blog/assets/img/1.4fd85c39.jpg" alt="this流程图"></p> <h2 id="闭包"><a href="#闭包" aria-hidden="true" class="header-anchor">#</a> 闭包</h2> <h3 id="什么是闭包？"><a href="#什么是闭包？" aria-hidden="true" class="header-anchor">#</a> 什么是闭包？</h3> <p>闭包就是指有权访问另一个函数作用域中的变量的函数。外部函数调用之后其变量对象本应该被销毁，但闭包的存在使我们仍然可以访问外部函数的变量对象</p> <div class="language- extra-class"><pre class="language-text"><code>例子: 闭包实现一个函数，每次调用返回值加1
function a(){
    var n = 1;
    return function(){
       return n++
    }
}
var b = a()

b() // 1
b() // 2
b() // 3
</code></pre></div><h3 id="闭包的使用场景"><a href="#闭包的使用场景" aria-hidden="true" class="header-anchor">#</a> 闭包的使用场景</h3> <ol><li>实现私有成员。</li> <li>保护命名空间，避免污染全局变量。</li> <li>缓存变量。</li></ol> <blockquote><p>常见的用闭包解决循环打印数值一样的问题</p></blockquote> <h3 id="使用闭包的注意事项"><a href="#使用闭包的注意事项" aria-hidden="true" class="header-anchor">#</a> 使用闭包的注意事项</h3> <ol><li><strong>内存泄漏</strong> - 由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题</li> <li>如果内部函数的变量和外部函数的变量名相同时，那么内部函数再也无法指向外部函数那个同名的变量</li></ol> <h2 id="浅拷贝、深拷贝"><a href="#浅拷贝、深拷贝" aria-hidden="true" class="header-anchor">#</a> 浅拷贝、深拷贝</h2> <h3 id="浅拷贝"><a href="#浅拷贝" aria-hidden="true" class="header-anchor">#</a> 浅拷贝</h3> <ol><li><code>Object.assign</code></li> <li>扩展运算符 <code>...</code></li></ol> <h3 id="深拷贝"><a href="#深拷贝" aria-hidden="true" class="header-anchor">#</a> 深拷贝</h3> <p>通常用转字符串的方法进行深拷贝 <code>JSON.parse(JSON.stringify(object))</code>。
但是此方法存在局限性</p> <ul><li>会忽略 <code>undefined</code></li> <li>会忽略 <code>symbol</code></li> <li>不能序列化函数</li> <li>不能解决循环引用的对象</li></ul> <div class="language- extra-class"><pre class="language-text"><code>let obj = {
  a: 1,
  b: {
    c: 2,
    d: 3,
  },
}
obj.c = obj.b
obj.e = obj.a
obj.b.c = obj.c
obj.b.d = obj.b
obj.b.e = obj.b.c
let newObj = JSON.parse(JSON.stringify(obj))
console.log(newObj)  //报错
</code></pre></div><div class="language- extra-class"><pre class="language-text"><code>let a = {
  age: undefined,
  sex: Symbol('male'),
  jobs: function() {},
  name: 'yck'
}
let b = JSON.parse(JSON.stringify(a))
console.log(b) // {name: &quot;yck&quot;} 只剩下name
</code></pre></div><p>需要深拷贝推荐使用 <a href="https://lodash.com/docs/4.17.15#cloneDeep" target="_blank" rel="noopener noreferrer"> lodash 的深拷贝函数<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <h2 id="原型和原型链"><a href="#原型和原型链" aria-hidden="true" class="header-anchor">#</a> 原型和原型链</h2> <h3 id="原型"><a href="#原型" aria-hidden="true" class="header-anchor">#</a> 原型</h3> <p>每个 JS 对象都有 <code>__proto__</code> 属性，这个属性指向了原型，实例的 <code>__proto__</code> 属性(原型) 等于其构造函数的<code>prototype</code>。</p> <h3 id="原型链"><a href="#原型链" aria-hidden="true" class="header-anchor">#</a> 原型链</h3> <p>对象的<code>__proto__</code> 属性指向原型，<code>__proto__</code> 将对象和原型连接起来组成了原型链。</p> <p>当在一个对象 obj 上访问某个属性时，如果不存在于 obj，那么便会去对象的原型也就是 <code>obj.__proto__</code>上去找这个属性。如果有则返回这个属性，没有则去对象 obj 的原型的原型也就是 <code>obj.__proto__.__proto__</code>去找，重复以上步骤。一直到访问纯对象的原型的原型<code>{}.__proto.__proto__</code>，也就是 <code>null</code>，直接返回 <code>undefined</code>。</p> <h3 id="new-运算符做了什么"><a href="#new-运算符做了什么" aria-hidden="true" class="header-anchor">#</a> new 运算符做了什么</h3> <div class="language- extra-class"><pre class="language-text"><code>function F(){
  console.log('这是构造函数')
}

// new 做了以下四步
var obj = {}; // 1. 创建一个空对象 obj
obj.__proto__ = F.prototype; // 2. 将空对象的 __proto__ 指向F函数对象的prototype对象
F.call(obj); // 3. 将F函数的 this 指向 obj, 并执行 F
return obj; // 返回 obj

// 自己实现一个 new 方法 
function myNew(){
  var obj = {}; // 1. 创建一个空对象 obj
  var Constructor = [].shift.call(arguments) //2. 获取构造函数
  obj.__proto__ = Constructor.prototype; //3. 将空对象的 __proto__ 指向构造函数的prototype对象
  var result = Constructor.apply(obj, arguments); //4. 将 this 指向 obj, 并执行Constructor函数
  return typeof result === &quot;object&quot; ? result : obj;//5. 如果返回值是一个对象就返回该对象，否则返回构造函数的一个实例对象
}
</code></pre></div><h2 id="var、let、const-区别"><a href="#var、let、const-区别" aria-hidden="true" class="header-anchor">#</a> var、let、const 区别</h2> <ul><li>函数提升优先于变量提升，函数提升会把整个函数挪到作用域顶部，变量提升只会把声明挪到作用域顶部。</li> <li>var 存在提升，我们能在声明之前使用。let、const 因为暂时性死区的原因，不能在声明前使用。</li> <li>var 在全局作用域下声明变量会导致变量挂载在 window 上，其他两者不会。</li> <li>let 和 const 作用基本一致，但是后者声明的变量不能再次赋值。</li></ul> <h2 id="模块化"><a href="#模块化" aria-hidden="true" class="header-anchor">#</a> 模块化</h2> <h3 id="模块化的好处"><a href="#模块化的好处" aria-hidden="true" class="header-anchor">#</a> 模块化的好处</h3> <ul><li>解决命名冲突</li> <li>提供复用性</li> <li>提高代码可维护性</li></ul> <h3 id="模块化的方式"><a href="#模块化的方式" aria-hidden="true" class="header-anchor">#</a> 模块化的方式</h3> <ol><li>立即执行函数</li></ol> <p>在早期，使用立即执行函数实现模块化是常见的手段，通过函数作用域解决了命名冲突、污染全局作用域的问题。</p> <div class="language- extra-class"><pre class="language-text"><code>(function(globalVariable){
   globalVariable.test = function() {}
   // ... 声明各种变量、函数都不会污染全局作用域
})(globalVariable)
</code></pre></div><ol start="2"><li>AMD和CMD (现已比较少使用)</li></ol> <div class="language- extra-class"><pre class="language-text"><code>// AMD
define(['./a', './b'], function(a, b) {
  // 加载模块完毕可以使用
  a.do()
  b.do()
})
// CMD
define(function(require, exports, module) {
  // 加载模块
  // 可以把 require 写在函数体的任意地方实现延迟加载
  var a = require('./a')
  a.doSomething()
})
</code></pre></div><ol start="3"><li>CommonJS</li></ol> <div class="language- extra-class"><pre class="language-text"><code>// a.js
module.exports = {
    a: 1
}
// or 
exports.a = 1

// b.js
var module = require('./a.js')
module.a // -&gt; log 1
</code></pre></div><ol start="4"><li>ES Module</li></ol> <div class="language- extra-class"><pre class="language-text"><code>// 引入模块 API
import XXX from './a.js'
import { XXX } from './a.js'
// 导出模块 API
export function a() {}
export default function() {}
</code></pre></div><h2 id="proxy"><a href="#proxy" aria-hidden="true" class="header-anchor">#</a> Proxy</h2> <p>Vue3.0 中将会通过 <code>Proxy</code> 来替换原本的 <code>Object.defineProperty</code> 来实现数据响应式。</p> <div class="language- extra-class"><pre class="language-text"><code>let p = new Proxy(target, handler)
</code></pre></div><p><code>target</code> 代表需要添加代理的对象，<code>handler</code> 用来自定义对象中的操作，比如可以用来自定义 <code>set</code> 或者 <code>get</code> 函数。</p> <p>Vue 中的响应式，需要我们在 get 中收集依赖，在 set 派发更新，之所以 Vue3.0 要使用 Proxy 替换原本的 API 原因在于 Proxy 无需一层层递归为每个属性添加代理，一次即可完成以上操作，性能上更好，并且原本的实现有一些数据更新不能监听到，但是 Proxy 可以完美监听到任何方式的数据改变，唯一缺陷可能就是浏览器的兼容性不好了。</p> <h2 id="数组遍历方法"><a href="#数组遍历方法" aria-hidden="true" class="header-anchor">#</a> 数组遍历方法</h2> <ol><li><h3 id="普通for循环"><a href="#普通for循环" aria-hidden="true" class="header-anchor">#</a> 普通for循环</h3></li></ol> <div class="language- extra-class"><pre class="language-text"><code>var arr = [1, 2, 3]
for(var i = 0; i &lt; arr.length; i++) { // 这里的i是代表数组的下标
    console.log(i); // 0, 1, 2
};
</code></pre></div><ol start="2"><li><h3 id="优化的-for-循环"><a href="#优化的-for-循环" aria-hidden="true" class="header-anchor">#</a> 优化的 for 循环</h3></li></ol> <div class="language- extra-class"><pre class="language-text"><code>var arr = [1, 2, 3]
for(var i = 0, len = arr.length; i &lt; len; i++) { // 这里的i是代表数组的下标
console.log(i); // 0, 1, 2 };　
</code></pre></div><p>使用临时变量，将长度缓存起来，避免重复获取数组长度，当数组较大时优化效果才会比较明显。这种方法基本上是所有循环遍历方法中性能最高的一种，并且这一类型的for循环可以通过用break来中断循环。</p> <ol start="3"><li><h3 id="for-of-遍历-这种遍历支持es6"><a href="#for-of-遍历-这种遍历支持es6" aria-hidden="true" class="header-anchor">#</a> for...of...遍历(这种遍历支持ES6)</h3></li></ol> <div class="language- extra-class"><pre class="language-text"><code>var arr = [1, 2, 3]
for(var item of arr) { // item代表数组里面的元素
    console.log(item); // 1, 2, 3
};　
</code></pre></div><ul><li><p>这是最简洁、最直接的遍历数组元素的语法</p></li> <li><p>这个方法避开了for-in循环的所有缺陷</p></li> <li><p>与forEach()不同的是，它可以正确响应break、continue和return语句</p></li> <li><p>性能要好于forin，但仍然比不上普通for循环</p></li></ul> <ol start="4"><li><h3 id="foreach"><a href="#foreach" aria-hidden="true" class="header-anchor">#</a> forEach()</h3></li></ol> <div class="language- extra-class"><pre class="language-text"><code>var arr = [1, 2, 3];
arr.forEach((item, index, arr) =&gt; { // item为arr的元素，index为下标，arr原数组
    console.log(item); // 1, 2, 3
    console.log(index); // 0, 1, 2
    console.log(arr); // [1, 2, 3]
});
</code></pre></div><p>这种遍历便捷还是挺便捷的，看起来优雅，对目标数组的操作很人性化，要元素给元素，要下标给下标，但是当某种情况你想<strong>中断遍历</strong>的时候，你就会感觉它就像鸡肋，食之无味，弃之可惜。由于foreach是Array型自带的，对于一些非这种类型的，无法直接使用(如NodeList)，所以才有了这个变种，使用这个变种可以让类似的数组拥有foreach功能。而且forEach的性能也会比普通的for循环弱。又下面的例子我们可以看到，我们常用的return false是可以终止代码继续往下执行的，但是在forEach遍历中，<strong>并没有终止循环</strong>，所以在用forEach的时候，要考虑使用场景了。</p> <ol start="5"><li><h3 id="some"><a href="#some" aria-hidden="true" class="header-anchor">#</a> some()</h3></li></ol> <div class="language- extra-class"><pre class="language-text"><code>var arr = [1, 2, 3];
arr.some((item, index, arr) =&gt; { // item为数组中的元素，index为下标，arr为目标数组
    console.log(item); // 1, 2, 3
    console.log(index); // 0, 1, 2
    console.log(arr); // [1, 2, 3]  
})
</code></pre></div><ul><li><p>some作为一个用来检测数组是否满足一些条件的函数存在，同样是可以用作遍历的函数签名同forEach，有区别的是当任一callback返回值匹配为true则会直接返回true，如果所有的callback匹配均为false，则返回false。</p></li> <li><p>some() 方法会依次执行数组的每个元素：</p></li> <li><p>如果有一个元素满足条件，则表达式返回true , 剩余的元素不会再执行检测。</p></li> <li><p>如果没有满足条件的元素，则返回false。</p></li></ul> <ol start="6"><li><h3 id="every"><a href="#every" aria-hidden="true" class="header-anchor">#</a> every()</h3></li></ol> <div class="language- extra-class"><pre class="language-text"><code>var arr = [1, 2, 3];
arr.every((item, index, arr) =&gt; { // item为数组中的元素，index为下标，arr为目标数组
    return item &gt; 0; // true
    return index == 0; // false
})
</code></pre></div><ul><li>every() 方法用于检测数组所有元素是否都符合指定条件（通过函数提供）。</li> <li>every() 方法使用指定函数检测数组中的所有元素：</li> <li>如果数组中检测到有一个元素不满足，则整个表达式返回 false ，且剩余的元素不会再进行检测。</li> <li>如果所有元素都满足条件，则返回 true。</li></ul> <ol start="7"><li><h3 id="filter"><a href="#filter" aria-hidden="true" class="header-anchor">#</a> filter()</h3></li></ol> <div class="language- extra-class"><pre class="language-text"><code>var arr = [1, 2, 3];
arr.filter(item =&gt; { // item为数组当前的元素
    return item &gt; 1; // [2, 3]
})
</code></pre></div><ul><li>filter() 方法创建一个新的数组，新数组中的元素是通过检查指定数组中符合条件的所有元素。</li></ul> <ol start="8"><li><h3 id="map"><a href="#map" aria-hidden="true" class="header-anchor">#</a> map()</h3></li></ol> <div class="language- extra-class"><pre class="language-text"><code>var arr = [1, 2, 3];
arr.map(item =&gt; { // item为数组的元素
    console.log(item); // 1, 2, 3
    return item * 2; // 返回一个处理过的新数组[2, 4, 6]
})
</code></pre></div><ul><li>map() 方法返回一个新数组，数组中的元素为原始数组元素调用函数处理后的值。</li> <li>map() 方法按照原始数组元素顺序依次处理元素。</li> <li>这种方式也是用的比较广泛的，虽然用起来比较优雅，但实际效率还比不上forEach</li></ul> <ol start="9"><li><h3 id="reduce"><a href="#reduce" aria-hidden="true" class="header-anchor">#</a> reduce()</h3></li></ol> <p><code>reduce</code> 可以将数组中的元素通过回调函数最终转换为一个值。</p> <div class="language- extra-class"><pre class="language-text"><code>const arr = [1, 2, 3]
const sum = arr.reduce((acc, current) =&gt; acc + current, 0)
console.log(sum)
</code></pre></div><p>对于 <code>reduce</code> 来说，它接受两个参数，分别是回调函数和初始值。</p> <p>reduce 过程</p> <ul><li>首先初始值为 0，该值会在执行第一次回调函数时作为第一个参数传入</li> <li>回调函数接受四个参数，分别为累计值、当前元素、当前索引、原数组，后三者想必大家都可以明白作用，这里着重分析第一个参数</li> <li>在一次执行回调函数时，当前值和初始值相加得出结果 1，该结果会在第二次执行回调函数时当做第一个参数传入</li> <li>所以在第二次执行回调函数时，相加的值就分别是 1 和 2，以此类推，循环结束后得到结果 6</li></ul></div> <div class="page-edit"><!----> <!----></div> <div class="page-nav"><p class="inner"><span class="prev">
        ←
        <a href="/blog/css.html" class="prev">
          CSS 基础
        </a></span> <span class="next"><a href="/blog/vue.html">
          vue面试题
        </a>
        →
      </span></p></div> </div> <!----></div></div>
    <script src="/blog/assets/js/app.186be814.js" defer></script><script src="/blog/assets/js/3.9ceac70b.js" defer></script>
  </body>
</html>
